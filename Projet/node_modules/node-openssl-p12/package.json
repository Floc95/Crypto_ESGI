{
  "name": "node-openssl-p12",
  "version": "0.1.8",
  "description": "openssl based client certificate generator for node JS",
  "main": "index.js",
  "author": {
    "name": "Alexey Nosov",
    "email": "mwmaleks@gmx.com",
    "url": "http://github.com/mwmaleks"
  },
  "maintainers": [
    {
      "name": "Alexey Nosov",
      "email": "mwmaleks@gmx.com",
      "url": "http://github.com/mwmaleks"
    },
    {
      "name": "Akhmethanov Pavel",
      "email": "pavel-power@ya.ru",
      "url": "http://github.com/pavelpower"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/mwmaleks/node-openssl-p12.git"
  },
  "private": false,
  "keywords": [
    "ssl",
    "PKC12",
    "p12",
    "https",
    "SPKAC",
    "spkac",
    "<keygen />",
    "keygen"
  ],
  "dependencies": {
    "underscore.deferred": "*"
  },
  "readmeFilename": "README.md",
  "license": "MIT",
  "readme": "##node-openssl-p12\n\nclient's ssl certificate generator for Node JS based on OpenSSL \n\n### Synopsis\n\nIf your application requires the client's authentication \nby SSL ceritficate this would be great if the server \ngenerate and sign clint's certificates automatically and then send \nit back to client. node-openssl-p12 allows you to implement this in two ways.\n\n### Description\n\nThe first one is to create `*.p12` file consisting with client's certificate, \nsave its sha-1 fingerprint into the database and send it to the client by e-mail\nfor example (which is not good, actually). \n\nIf you do not need to manage different access rights for your authorized users and you do \nnot care about unauthorized users those may not understand why the connection was dropped, \nyou just turn `rejectUnauthorized: true` in HTTPS settings (Express JS). \n\nIf `rejectUnauthorized: false`, but `requestCert: true` (see example below), \nthe server will not drop the connection and you have to manage authentication manually \nby SHA-1 fingerprint as well. This is possible by calling:\n\n`req.connection.getPeerCertificate().fingerprint`\n\nBefore rendering the private page you just compare this fingerprint with those you saved as\nresult of node-openssl-p12 work.\n\nThe second way (most preferred) is about using `<keygen />` HTML5 tag (or google it for EE). \n`<keygen />` genereates a pair of private an public key. The public key is sent to the server with the form data \nwhich `<keygen />` tag was placed into. node-openssl-p12 use this key to create CPKAC, and certificate \nfile that is should be sent back to the browser as response with the header \n`'Content-Type': 'application/x-x509-user-cert'`. This is the perfect way to free up users of knowledge how to install\nssl certificate into the browser. The fingerprint is also generated and saved for further usage. \n\nThis second way implemented using both self signed CA and valid SLL signed by some third party CA.\n\n\n### Install\n\n  ```\n  npm install node-openssl-p12\n  ```\n### Use the first way (PKC12)\n\nNOTE: The current state it works only with self signed certificates.\n\nCreate `/ssl` folder in your project rootDir\nand put `ca.key` , `ca.crt` (Certificate Authority) files, those \nare to sign your client certificates.\n\n\n```js\n  var p12 = require('node-openssl-p12').createClientSSL;\n  var p12options = {\n    bitSize: 2048,\n    clientFileName :'client001',\n    C:'EX',\n    ST: 'Example',\n    L: 'Example',\n    O: 'Example',\n    OU: 'Example',\n    CN: 'Example',\n    emailAddress: 'example@example.ex',\n    clientPass: 'q1w2e3r4t5y6',\n    caFileName: 'ca',\n    serial: '01',\n    days: 365\n};\n\np12(p12options).done(function(options, sha1fingerprint) {\n    console.log('SHA-1 fingerprint:', sha1fingerprint);\n}).fail( function(err) {\n    console.log(err);\n});\n```\n\nEach certificate should be created with different `serial` and `clientFileName` \nor `clientFileName` files should be removed before the next `createClientSSL` call.\n\n`*.p12` file saved in `ssl` folder. All done.\n\n\n### Use the second way (<keygen /> and SPKAC)\n\nCreate `/ssl` folder in your project rootDir\nand put `ca.key` , `ca.crt` (Certificate Authority) files, those \nare to sign your client certificates. If you use the certificate signed by some third party\nuse `server.key` and `server.crt`\n\nPerform these commands in `ssl` folder.\n\n```\n$ mkdir db\n$ mkdir db/certs\n$ mkdir db/newcerts\n$ touch db/index.txt\n$ echo \"02\" > db/serial\n```\nIt creates your certificates' database.\n\nThen create `ca.config`\n```\n$ vim ca.config\n```\n\nand put this code inside:\n\n```\n[ ca ]\ndefault_ca = CA_CLIENT\n\n[ CA_CLIENT ]\ndir = ./db\ncerts = $dir/certs\nnew_certs_dir = $dir/newcerts\n\ndatabase = $dir/index.txt\nserial = $dir/serial\ncertificate = ./ca.crt\nprivate_key = ./ca.key\n\ndefault_days = 365\ndefault_crl_days = 7\ndefault_md = md5\n\npolicy = policy_anything\n\n[ policy_anything ]\ncountryName = optional\nstateOrProvinceName = optional\nlocalityName = optional\norganizationName = optional\norganizationalUnitName = optional\ncommonName = optional\nemailAddress = optional\n```\n\nIMPORTANT:\n`certificate` and `private_key` options should be specified with \nyour `*.crt` and `*.key` files you use.\n\n\n```js\n  var p12 = require('node-openssl-p12').createClientSSL;\n  var p12options = {\n    clientFileName :'client001',\n    C:'EX',\n    ST: 'Example',\n    L: 'Example',\n    O: 'Example',\n    OU: 'Example',\n    CN: 'Example',\n    emailAddress: 'example@example.ex',\n    days: 365\n    publicKey: req.body.public_key // a long string from <keygen /> tag\n};\n\np12(p12options).done(function(options, sha1fingerprint) {\n\n    console.log('SHA-1 fingerprint:', sha1fingerprint);\n}).fail( function(err) {\n\n    console.log(err);\n});\n```\nNOTE: if you provide `publicKey` string `createClientSSL` works completely \ndifferent way suitable only for `<ketgen />` case.\n\n\nAll done. Now just send the file back to the browser like this:\n\n```js\nfs.readFile( path.join( rootDir, 'ssl', 'client001'), function(err, data) {\n\n        if (err) {\n           console.error('error while open client ssl file:', err);\n           return;\n        }\n        res.set('Last-Modified', (new Date).setHours(-24));\n        res.set('Accept-Ranges', 'bytes');\n        res.set('Content-Length', data.length);\n        res.set('Content-Type', 'application/x-x509-user-cert');\n        res.send(data);\n    });\n```\nNOTE:\nIf you discover an error after then second certificate generation\nopen `/ssl/db/index.txt.attr` and switch `unique_subject = no`\n\n\n### Options description\n\n* `bitSize:` client key length (defaults to 2048)\n* `clientFileName :` name of the client's ssl-certificate file (defaults to 'client001')\n* `C:` CSR country field (defaults to 'Example')\n* `ST:` CSR state field (defaults to 'Example')\n* `L:` CSR locality field (defaults to 'Example')\n* `O:` CSR organization field (defaults to 'Example')\n* `OU:` CSR organizational unit field (defaults to 'Example')\n* `CN:` CSR common name field (defaults to 'Example')\n* `emailAddress:` CSR email address field (defaults to 'example@example.ex')\n* `clientPass:` Clients' password to encrypt PKS12 (.p12) file (defaults to q1w2e3r4t5y6)\n* `caFileName:` CA files name (without extension), both files *.key and *.crt should exist (defaults to 'ca')\n* `serial:` Client certificate serial number (defaults to '01')\n* `days:` Client certificate valid period (defaults to 365)\n* `publicKey:` public key - `req.body.public_key` from `<keygen name= \"public_key\"/>`\n\n### HTTPS authentication example\n\n```js\nvar fs = require('fs'),\n    http = require('http'),\n    https = require('https'),\n    express = require('express');\n    \nvar port = 443;\n\nvar httpsOptions = {\n            key: './ssl/server.key',\n            cert: './ssl/server.crt',\n            ca: './ssl/ca.crt',\n            requestCert: true,\n            rejectUnauthorized: false,// using rejectUnauthorized: true - drops \n                                      // connection if user has not certificate\n            agent: false\n        };\n\nvar app = express();\n\n/* express options are avoided */\n\n// SHA-1 fingerprint is node-openssl-p12 result that might be linked to exact user\nvar sha1fingerprint = 'CF:D4:95:58:04:9B:76:73:DC:EE:07:88:27:B0:48:1E:16:9D:F1:F9';\n\napp.get('/', someHttpsMiddleWare, function (req, res) {\n\n   if ( sha1fingerprint === req.connection.getPeerCertificate().fingerprint ) {\n        res.send('Authorized User!');\n   } else {\n        res.send('Unauthorized User!');\n   }\n});\nvar server = https.createServer( httpsOptions, app ).listen(port, function() {\n  console.log('Express server listening on port ' + port);\n});\n```\nYou will also need someHttpsMiddleWare (this one for example https://github.com/tgies/client-certificate-auth)\n\nNow all visitors those having not ssl-certificate installed into there browsers are \nredirected or rejected, all those how have certificates can visit your https protected \npages, but only that one how has the certificate with exact SHA-1 fingerprint you remembered \nwhen created this certificate might be allowed to page 'Authorized User!' So you can maintain \nyour users' data base with SHA-1 fingerprints, granting different HTTPS access rights.\n",
  "bugs": {
    "url": "https://github.com/mwmaleks/node-openssl-p12/issues"
  },
  "homepage": "https://github.com/mwmaleks/node-openssl-p12",
  "_id": "node-openssl-p12@0.1.8",
  "dist": {
    "shasum": "6449652a8a4872a44bebe7de30eaef8f0db1eeb6"
  },
  "_from": "node-openssl-p12@",
  "_resolved": "https://registry.npmjs.org/node-openssl-p12/-/node-openssl-p12-0.1.8.tgz"
}
